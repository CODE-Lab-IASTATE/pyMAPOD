# createKriging

# general process:
# 1. experimental design (generated by user)
# 2. trend function ("ordinary" by default)
# 3. correlation function ("anisotropic ellipsoidal, matern-5_2" by default)
# 4. estimation method ("cross validation" by default)
# 5. optimization method ("genetic algorithm" by default)

# created on July 27, 2018
# modified on July 27, 2018
# developed by Leifur Leifsson (assisted professor)
#              Xiaosong Du (Ph.D. student)

import algKriging
import numpy as npy
from scipy import optimize
from scipy import stats

def createKriging(setting, *args):
    #PCE = args[0]
    # information matrix of generic terms
    F = algKriging.infMatrix(setting, *args)
    
    # correlation matrix
    R = algKriging.corMatrix(setting)
    
    # solving for unknown parameters: "theta", "beta", and "var"
    if setting['corrType'].endswith('aniso'):        
        theta0 = npy.ones([npy.shape(setting['exp_x'])[1], 1])

    else:
        theta0 = 1.
        
    # opt = optimize.minimize(lambda x: algKriging.thetaFunc(x, F, R, setting), theta0, method= setting['optimizer'], bounds = setting['bounds'])
    # opt = optimize.root(lambda x: algKriging.thetaFunc(x, F, R, setting), theta0, method= setting['optimizer'])
    opt = optimize.differential_evolution(lambda x: algKriging.thetaFunc(x, F, R, setting), bounds = setting['bounds'], strategy='best2bin')
    print opt
    
    R_pred = algKriging.RFunc(opt['x'], R, setting)
    
    beta = algKriging.betaFunc(F, R_pred, setting)
    
    var = algKriging.varFunc(beta, F, R_pred, setting)
    
    model = {}
    model['theta'] = opt['x']
    model['beta']  = beta
    model['var']   = var
    model['F']     = F
    model['R_pred']= R_pred
    
    return model
    

def predictor(x_pred, model, setting, *args):
    
    f = algKriging.infMatrix_pred(x_pred, setting, *args)

    r = algKriging.corMatrix_pred(x_pred, setting)
    
    r_pred = algKriging.RFunc_pred(model['theta'], r, x_pred, setting)
    
    mu = npy.matmul(npy.transpose(f), model['beta']) \
       + npy.matmul(npy.matmul(npy.transpose(r_pred), npy.linalg.inv(model['R_pred'])), setting['exp_y'] - npy.matmul(model['F'], model['beta']))
    
    u = npy.matmul(npy.matmul(npy.transpose(model['F']), npy.linalg.inv(model['R_pred'])), r_pred) - f  
    
    mat1 = npy.matmul(npy.matmul(npy.transpose(r_pred), npy.linalg.inv(model['R_pred'])), r_pred)
    mat2 = npy.linalg.inv(npy.matmul(npy.matmul(npy.transpose(model['F']), npy.linalg.inv(model['R_pred'])), model['F']))
    mat3 = npy.matmul(npy.matmul(npy.transpose(u), mat2), u)
    
    var_pred = model['var'] * (1 - mat1 + mat3)
    
    ci = npy.array([mu.reshape(len(mu), 1) - 1.96*npy.sqrt(npy.diag(var_pred).reshape(len(mu), 1)), \
                    mu.reshape(len(mu), 1) + 1.96*npy.sqrt(npy.diag(var_pred).reshape(len(mu), 1))]).reshape(2, len(mu))
    ci = npy.transpose(ci)
    
    return mu, ci, npy.diag(var_pred)
    
    
def pod_opt(x, model, setting, a_threshold, X, pod):
    
    x_pred = npy.concatenate((npy.log(x)*npy.ones([len(X), 1]), X), axis = 1)
    
    y_kriging, ci_kriging, var_kriging = predictor(x_pred, model, setting)
    
    a_temp = (npy.log(a_threshold) - y_kriging)/((npy.sqrt(var_kriging)).reshape(len(var_kriging), 1))

    f = npy.abs(pod - npy.mean(1 - stats.norm.cdf(a_temp)))

    return f

def pod_ci_opt(x, model, setting, a_threshold, X, pod):
    
    x_pred = npy.concatenate((npy.log(x)*npy.ones([len(X), 1]), X), axis = 1)
    
    y_kriging, ci_kriging, var_kriging = predictor(x_pred, model, setting)
    
    a_temp = (npy.log(a_threshold) - ci_kriging[:, 0])/((npy.sqrt(var_kriging)).reshape(len(var_kriging), 1))

    f = npy.abs(pod - npy.mean(1 - stats.norm.cdf(a_temp)))

    return f
    
def aCal(a_threshold, model, setting, X):

     pod  = npy.zeros([30, 1])
     pod_ci  = npy.zeros([30, 1])
               
     size = npy.linspace(0.1, 1, 30)
     for i in xrange(0, 30):
         x_pred = npy.concatenate((npy.log(size[i])*npy.ones([len(X), 1]), X), axis = 1)
         y_kriging, ci_kriging, var_kriging = predictor(x_pred, model, setting)
         a_temp = (npy.log(a_threshold) - y_kriging)/((npy.sqrt(var_kriging)).reshape(len(var_kriging), 1))
         pod[i, 0] = npy.mean(1 - stats.norm.cdf(a_temp))
         a_ci = (npy.log(a_threshold) - ci_kriging[:, 0])/((npy.sqrt(var_kriging)).reshape(len(var_kriging), 1))
         pod_ci[i, 0] = npy.mean(1 - stats.norm.cdf(a_ci))
     return pod, pod_ci
         
